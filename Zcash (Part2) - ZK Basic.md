# Zcash (Part2) - ZK Basic

## NP问题

![Deterministic](https://pic3.zhimg.com/v2-63a801bad204f28707afc8beb15c114e_r.jpg)

> NP问题是指可以在多项式时间内被非确定性图灵机解决的问题

一些简单的数学问题，比如将一个数组从小到大进行排序的问题，被称为P问题（Polynomial time problem）。这些问题能够由确定性图灵机（deterministic turing machine）在多项式复杂度的时间范围内解决。P问题的执行函数是分步确定且唯一的，对于每一个中间状态都有一个明确的执行方向。

而NP问题（Nondeterministic Polynomial time problem）并非是能够在多项式时间内解决，而是能够在多项式时间内被确定性图灵机验证的问题。NP问题的每一个中间状态有多个选择可以执行，但不明确直接导向正确的输出答案，这样的执行机也被称为不确定性图灵机（nondeterministic turing machine）。我们同样可以将NP问题定义为可以在多项式时间内被非确定性图灵机解决的问题。

从直觉上而言，所有的P问题都应属于NP问题，但是并不是所有NP问题都是P问题，不过该结论仅属于假设，目前难以证明。NP问题的求解过程复杂，但是验证解的过程并不复杂。

## 简单例子

> $x^3 + x + 5 = 35$

我们先尝试以这个简单的方程求解为例，梳理zk-SNARK的生成过程。

![zk-SNARK](https://www.ipfsnews.cn/wp-content/uploads/2020/07/2020070207235842.png)

### Algebraic Circuit

我们首先需要将NP问题转化为仅由加法电路和乘法电路组成的代数电路，该电路应用于验证NP问题的解，而非直接求解。

因此我们取$x$为输入，电路应构建为：

第一层，$sym_1 = x * x$ // x^2

第二层，$y = sym_1 * x$ // x^3

第三层，$sym_2 = y + x$ // x^3 + x

最后一层，$out = sym_2 + 5$ // x^3 + x + 5

即，乘法门->乘法门->加法门->加法门。

### R1CS

之后我们需要根据电路设置三个向量约束$(a,b,c)$构成R1CS。在具体的形式化定义中，对整个电路的约束应当表达为组形式$(A,B,C)$，任意的$(a_n,b_n,c_n)$只是对其中一层电路的约束。

#### 简单介绍

对于这组约束，R1CS的解$s$必须满足$s·a*s·b-s·c=0$，对其中的每一层都应该满足。

比如某一层电路的约束：

$a = (5,0,0,0,0,1)$，$b = (1,0,0,0,0,0)$，$c = (0,0,1,0,0,0)$

和一个有效解：

$s = (1,3,35,9,27,30)$

![R1CS](https://pic4.zhimg.com/80/v2-85fea818228b399c967f730f52dcd1df_1440w.png)

我们将$s$和$a$做点积获得$35$，和$b$做点积获得$1$，和$c$做点积获得$35$，因此条件验证：

$s·a*s·b-s·c=35*1-35=0$，故$s$满足R1CS的解要求。

#### 回到例子

接下来我们回到方程$x^3 + x + 5 = 35$的R1CS转换过程。

我们首先明确上一节构建的AC定义了四层电路，和以下几个变量：

> $x, out, sym_1, y, sym_2$

这里再引入一个常量变量$one$放在首位，完成算数电路的拍平，即构成向量:

$s=(one, x, out, sym_1, y, sym_2)$

1号位置为常量变量，2号位置为输入，3号位置为输出，其余4、5、6号位置为中间电路的顺序输出。

按照上述构成，我们将能够通过该电路验证的向量形式定义为:

$s=(s_0, s_1, s_2, s_3, s_4, s_5)$

1号位置为常量变量，2号位置为输入，3号位置为输出，其余为中间电路的顺序输出。

我们先尝试对第一个门构建约束$(a,b,c)$，乘法门非常的直接，

第一个门的输入为向量2号位置的$s_1$，输出为4号位置的$s_3$，同时和向量在其他位置的数值无关。

例子直接给出了该门的约束，但是没有描述过程：

$a = (0,1,0,0,0,0)$，$b = (0,1,0,0,0,0)$，$c = (0,0,0,1,0,0)$

反推过程，我们可以从已有条件获得两个等式，用方程来描述：

1. $s_3 = s_1 * s_1$，即门的输入输出必须匹配；
2. $s·a*s·b-s·c$，即$s_1 * a_2 * s_1 * b_2 - s_3 * c_4 = 0$，其中$m_n$代表$m$约束的第$n$个位置.

则可知，$a_2 * b_2 - c_4 = 0$，我们按照这条等式取最小单位值，就能够获得上面的结果。

我们再尝试对第二个门构建约束$(a,b,c)$，

第二个门的输入为向量4号位置的$s_3$和2号位置的$s_1$，输出为向量5号位置的$s_4$，同时和其他位置无关。

我们同样可以获得两个等式：

1. $s_4 = s_3 * s_1$；
2. $s_3 * a_4 * s_1 * b_2 - s_4 * c_5 = 0$。

则可知，$a_4 * b_2 - c_5 = 0$。我们按照这条等式取最小单位值，就能够获得:

$a = (0,0,0,1,0,0)$，$b = (0,1,0,0,0,0)$，$c = (0,0,0,0,1,0)$

我们再尝试对第三个门构建约束$(a,b,c)$，

第三个门的输入为向量5号位置的$s_4$和2号位置的$s_1$，输出为向量6号位置的$s_5$，同时和其他位置无关。

> Here, the pattern is somewhat different: it’s multiplying the first element in the solution vector by the second element, then by the fifth element, adding the two results, and checking if the sum equals the sixth element. Because the first element in the solution vector is always one, this is just an addition check, checking that the output equals the sum of the two inputs.

加法门引入$s_0$，也就是$one$，先对两个门输入分别做一次乘法再求和，将门等式转换为$(x+y)*one-sym_2=0$，也就是$(s_1 + s_4) * s_0 - s_5 = 0$。

这时候用方程来解会显得困难，这里尝试分析现有约束的构成模式。

对于第一和第二个门，它们的约束都表现为三个仅包含一个$1$的单位向量，且$1$存在的位置很有特征。

约束向量$a$和$b$的$1$位置都正好对应门输入在电路向量中的位置，而约束向量$c$的$1$位置则是门输出在电路向量的位置。对于下面的两个加法门，这里只能改用相同的规律分析。

例子给出第三个门的约束为：

$a = (0,1,0,0,1,0)$，$b = (1,0,0,0,0,0)$，$c = (0,0,0,0,0,1)$

$c$向量很明显，$1$位置是加法电路输出的$s_5$。$a$向量给了两个$1$，位置分别对应加法电路的两个输入$s_1$和$s_4$。$b$向量仅给了一个$1$，位置对应常量$one$。

以相同的模式分析第四个门，约束为：

$a = (5,0,0,0,0,1)$，$b = (1,0,0,0,0,0)$，$c = (0,0,1,0,0,0)$

$c$向量很明显，$1$位置是加法电路输出的$s_2$。$a$向量给了一个$5$一个$1$，位置分别对应加法电路的两个输入$s_0$和$s_5$。$b$向量仅给了一个$1$，位置对应常量$one$。

在验证当中，也就是$s·a*s·b-s·c$的计算上，$s·a$实际计算了电路的输出，$s·b$计算了结果的放大倍数，$s·c$就是电路的输出结果，很容易验证上述模式的有效性。

鉴于大部分文章都没有给出电路约束的计算过程，这里也只总结两条规律：

1. 对于乘法门，约束向量$a$和$b$分别接收门的两个输入，分先后。当输入为变量时，接收位置均为$1$，当输入位置为常量时，接收位置为常量相对$one$的倍数；
2. 对于加法门，约束向量$a$接收加法门的两个输入，不分先后，数值同上理，向量$b$接收两个门输入的放大倍数，数值也同上理；
3. 在任意门中，约束向量$c$均接收门的单一输出，接收位置均为$1$。

现在我们可以获得一个完整的电路约束：

```
A
[0, 1, 0, 0, 0, 0]
[0, 0, 0, 1, 0, 0]
[0, 1, 0, 0, 1, 0]
[5, 0, 0, 0, 0, 1]
B
[0, 1, 0, 0, 0, 0]
[0, 1, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
[1, 0, 0, 0, 0, 0]
C
[0, 0, 0, 1, 0, 0]
[0, 0, 0, 0, 1, 0]
[0, 0, 0, 0, 0, 1]
[0, 0, 1, 0, 0, 0]
```

### QAP

从R1CS到QAP的转换是形式上不同但逻辑上等价的，但是相比于用编程语言表述并验证电路约束，使用QAP验证的效率会明显更高。后者期望用多项式来表示相同的验证逻辑。

#### 简单介绍

求解QAP使用拉格朗日插值的办法，也就是根据线条经过的点坐标来计算经过所有这些点的曲线方程。

比如想让一条曲线经过点(1,3)、(2,2)和(3,4)，我们先尝试用直观方法计算一个有效的多项式。

首先锚定第一个点(1,3)，暂时把$x=2$和$x=3$两个位置放在$y=0$上，计算多项式的第一部分。

根据后半条件，我们简单构造$(x-2)*(x-3)$，它必然经过(2,0)和(3,0)。

再将它$x=1$的位置挪到我们想要的地方，也就是对曲线进行缩放。

缩放的方式是计算$(x-2)*(x-3)*3/((1-2)*(1-3))$，第一个乘数$3$是我们想要的$y$值，括号内的$1$则是我们锁定的$x$。简化后的结果是$1.5*x^2+7.5*x+9$，现在这条曲线就经过(1,3)。

其次锚定第二个点，把$x=1$和$x=3$两个位置放在$y=0$上，计算多项式的第二部分。

然后锚定第三个点，把$x=1$和$x=2$两个位置放在$y=0$上，计算多项式的第三部分。

最后把三个多项式加在一起，这样这条曲线必然同时经过(1,3)、(2,2)和(3,4)三个点，结果为$y=1.5*x^2-5.5*x+7$。

上述计算过程就是直观的拉格朗日插值办法，实际的公式就是直接上述三部分的合算，获得$n-1$阶的多项式结果，$n$为经过的点数量，时间复杂度上有很大的优化空间。

#### 回到例子

我们已经在R1CS一节中获得了三组四个长度为6的电路约束，现在把它们转化为QAP多项式的系数矩阵。

该电路一共四层，所以我们需要4个坐标来做四次验证，直接取$x=1,2,3,4$，让每个多项式都通过某组约束的某一列值。注意，因为这里每次都经过四个点，所以我们的多项式是三阶的。

我们首先取A组约束的第一列值$[0,0,0,5]$，要求多项式都经过四个点(1,0)、(2,0)、(3,0)和(4,5)，获得我们的第一个多项式系数组$[-5.0, 9.166, -5.0, 0.833]$，它代表多项式$0.833*x^3-5*x^2+9.166*x-5$。

我们再取A组约束的第二列值$[1,0,1,0]$，要求多项式都经过四个点(1,1)、(2,0)、(3,1)和(4,0)，获得我们的第二个多项式系数组$[8.0, -11.333, 5.0, -0.666]$。

最后我们在A组约束上获得6组这样的多项式参数：

```
A
[-5.0, 9.166, -5.0, 0.833]
[8.0, -11.333, 5.0, -0.666]
[0.0, 0.0, 0.0, 0.0]
[-6.0, 9.5, -4.0, 0.5]
[4.0, -7.0, 3.5, -0.5]
[-1.0, 1.833, -1.0, 0.166]
```

同理，B组约束和C组约束也获得同样大小的多项式参数组：

```
B
[3.0, -5.166, 2.5, -0.333]
[-2.0, 5.166, -2.5, 0.333]
[0.0, 0.0, 0.0, 0.0]
[0.0, 0.0, 0.0, 0.0]
[0.0, 0.0, 0.0, 0.0]
[0.0, 0.0, 0.0, 0.0]
C
[0.0, 0.0, 0.0, 0.0]
[0.0, 0.0, 0.0, 0.0]
[-1.0, 1.833, -1.0, 0.166]
[4.0, -4.333, 1.5, -0.166]
[-6.0, 9.5, -4.0, 0.5]
[4.0, -7.0, 3.5, -0.5]
```

### Verification

上面提到，QAP的逻辑作用和R1CS是一样的，就是在给出有效解的情况下验证所有的电路计算和结果都满足预期。

我们已知R1CS约束能够对拍平的电路向量，也就是电路的基数、输入、输出和中间结果进行验算。

那么QAP也可以完成同样的事情，事情还更加简单，因为我们只验证输入证明和最简证明的等价性。

![QAP verification](https://upload-images.jianshu.io/upload_images/13960264-bb7e65f1397e7a41.png)

对于输入的解向量$s = (1,3,35,9,27,30)$，我们通过QAP验证它的有效性。我们将R1SC约束公式$s·a*s·b-s·c$直接应用到整个电路，拆分为三个部分分别计算。

比如$A(x)=A·s=[43.0, -73.333, 38.5, -5.166]$，该结果的形式和QAP相似，实际表示了一个临时多项式：

$A(x)=-5.166*x^3+38.5*x^2-73.333*x+43$，$x$是我们的电路门取值。

以$43.0$为例，该结果来源于式子$-5*1+8*3+0*35-6*9+4*27-1*30$，每个加项的左侧乘数代表A组每个多项式的0次幂系数$[-5,8,0,-6,4,-1]$，右侧乘数即为输入的解向量$[1,3,35,9,27,30]$。

同样的，也可以看到$-73.333=9.166*1-11.333*3+0*35+9.5*9-7*27+1.833*30$，以及其他幂次项系数的计算过程。

同理我们可以计算，

$B(x)=B·s=[-3.0, 10.333, -5.0, 0.666]$，$C(x)=C·s=[-41.0, 71.666, -24.5, 2.833]$

此时，验证解向量$s$是电路有效解的问题就变成了当$x=1,2,3,4$时，验证

$A(x)*B(x)-C(x)=0$

但是我们并不会真的去计算它，而是计算这个式子的不同幂次系数。因为我们计算了三阶多项式的乘法，所以现在系数向量的长度变成了7：

$t=[-88.0, 592.666, -1063.777, 805.833, -294.777, 51.5, -3.444]$

向量$t$表示的六阶多项式和$A(x)*B(x)-C(x)$是等价的。

接下来我们证明它和最简多项式$Z(x)=(x-1)*(x-2)*(x-3)*(x-4)$的等价性，该式同样在$x=1,2,3,4$时都获得$0$值。

我们也使用系数向量的形式表述多项式$Z(x)$：

$Z=[24, -50, 35, -10, 1]$

等价性验证计算$t/Z$，也就是

$h=t/Z=[-3.666, 17.055, -3.444]$，两个多项式的除法没有产生余式，说明$t/Z$发生了整除。

这就证明$t$在$x=1,2,3,4$时都获得$0$值，也就意味着$Z$和$t$是等价的两个验证多项式。

### 总结

在AC->R1SC->QAP的过程中，Prover在不停的将原来NP问题的解证明逻辑进行转换。Prover一开始用代数证明$3$是方程$x^3 + x + 5 = 35$的解，之后用电路约束证明，然后用一个巨大的多项式$t$证明。

但是QAP的作用就在于只需要证明原电路和最简多项式的等价性，就可以验证$3$是方程$x^3 + x + 5 = 35$的解，而不用完整实施问题的验证计算。

## References

如果对上述文字的任何部分感到疑惑，或许可以从以下的资料中找到遗漏的细节。

1. [原文 - 《Quadratic Arithmetic Programs: from Zero to Hero》](https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649);
2. [原文的中文翻译版 - 《V神对QAP深入浅出的分析二》](https://www.jianshu.com/p/257b6e70d3d3);
3. [包含一些计算过程的扩展版 - 《二次算术程序QAP：Vitalik关于零知识证明的论述1》](https://www.jianshu.com/p/c81cb6c01d76);
4. [一些逻辑细节的补充 - 《理解Groth16，一些细节上的说明》](https://learnblockchain.cn/article/3835)；
5. [NP问题 - 《从图灵机到NP问题（下）》](https://zhuanlan.zhihu.com/p/353053434)。